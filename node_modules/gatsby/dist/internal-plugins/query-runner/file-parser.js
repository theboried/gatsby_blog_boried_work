"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.default = void 0;

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _babelTraverse = _interopRequireDefault(require("babel-traverse"));

const fs = require(`fs-extra`);

const crypto = require(`crypto`); // Traverse is a es6 module...


const babylon = require(`babylon`);

const getGraphQLTag = require(`babel-plugin-remove-graphql-queries`).getGraphQLTag;

const report = require(`gatsby-cli/lib/reporter`);

const apiRunnerNode = require(`../../utils/api-runner-node`);

const BABYLON_OPTIONS = {
  allowImportExportEverywhere: true,
  allowReturnOutsideFunction: true,
  allowSuperOutsideMethod: true,
  sourceType: `unambigious`,
  sourceFilename: true,
  plugins: [`jsx`, `flow`, `doExpressions`, `objectRestSpread`, `decorators`, `classProperties`, `classPrivateProperties`, `classPrivateMethods`, `exportDefaultFrom`, `exportNamespaceFrom`, `asyncGenerators`, `functionBind`, `functionSent`, `dynamicImport`, `numericSeparator`, `optionalChaining`, `importMeta`, `bigInt`, `optionalCatchBinding`, `throwExpressions`, `pipelineOperator`, `nullishCoalescingOperator`]
};

const getMissingNameErrorMessage = file => report.stripIndent`
  GraphQL definitions must be "named".
  The query with the missing name is in ${file}.
  To fix the query, add "query MyQueryName" to the start of your query.
  So instead of:
    {
      allMarkdownRemark {
        totalCount
      }
    }

  Do:
    query MyQueryName {
      allMarkdownRemark {
        totalCount
      }
    }
`;

function parseToAst(_x, _x2) {
  return _parseToAst.apply(this, arguments);
}

function _parseToAst() {
  _parseToAst = (0, _asyncToGenerator2.default)(function* (filePath, fileStr) {
    let ast; // Preprocess and attempt to parse source; return an AST if we can, log an
    // error if we can't.

    const transpiled = yield apiRunnerNode(`preprocessSource`, {
      filename: filePath,
      contents: fileStr
    });

    if (transpiled && transpiled.length) {
      for (var _iterator = transpiled, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref = _i.value;
        }

        const item = _ref;

        try {
          const tmp = babylon.parse(item, BABYLON_OPTIONS);
          ast = tmp;
          break;
        } catch (error) {
          report.error(error);
          continue;
        }
      }

      if (ast === undefined) {
        report.error(`Failed to parse preprocessed file ${filePath}`);
      }
    } else {
      try {
        ast = babylon.parse(fileStr, BABYLON_OPTIONS);
      } catch (error) {
        report.error(`There was a problem parsing "${filePath}"; any GraphQL ` + `fragments or queries in this file were not processed. \n` + `This may indicate a syntax error in the code, or it may be a file type ` + `That Gatsby does not know how to parse.`);
      }
    }

    return ast;
  });
  return _parseToAst.apply(this, arguments);
}

function findGraphQLTags(_x3, _x4) {
  return _findGraphQLTags.apply(this, arguments);
}

function _findGraphQLTags() {
  _findGraphQLTags = (0, _asyncToGenerator2.default)(function* (file, text) {
    return new Promise((resolve, reject) => {
      parseToAst(file, text).then(ast => {
        let queries = [];

        if (!ast) {
          resolve(queries);
          return;
        }

        (0, _babelTraverse.default)(ast, {
          ExportNamedDeclaration(path, state) {
            path.traverse({
              TaggedTemplateExpression(innerPath) {
                const gqlAst = getGraphQLTag(innerPath);

                if (gqlAst) {
                  gqlAst.definitions.forEach(def => {
                    if (!def.name || !def.name.value) {
                      report.panic(getMissingNameErrorMessage(file));
                    }
                  });
                  queries.push(...gqlAst.definitions);
                }
              }

            });
          }

        });
        resolve(queries);
      }).catch(reject);
    });
  });
  return _findGraphQLTags.apply(this, arguments);
}

const cache = {};

class FileParser {
  parseFile(file) {
    return (0, _asyncToGenerator2.default)(function* () {
      let text;

      try {
        text = yield fs.readFile(file, `utf8`);
      } catch (err) {
        report.error(`There was a problem reading the file: ${file}`, err);
        return null;
      }

      if (text.indexOf(`graphql`) === -1) return null;
      const hash = crypto.createHash(`md5`).update(file).update(text).digest(`hex`);

      try {
        let astDefinitions = cache[hash] || (cache[hash] = yield findGraphQLTags(file, text));
        return astDefinitions.length ? {
          kind: `Document`,
          definitions: astDefinitions
        } : null;
      } catch (err) {
        report.error(`There was a problem parsing the GraphQL query in file: ${file}`, err);
        return null;
      }
    })();
  }

  parseFiles(files) {
    var _this = this;

    return (0, _asyncToGenerator2.default)(function* () {
      const documents = new Map();
      return Promise.all(files.map(file => _this.parseFile(file).then(doc => {
        if (!doc) return;
        documents.set(file, doc);
      }))).then(() => documents);
    })();
  }

}

exports.default = FileParser;
//# sourceMappingURL=file-parser.js.map