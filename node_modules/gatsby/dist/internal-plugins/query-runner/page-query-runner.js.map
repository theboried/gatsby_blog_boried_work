{"version":3,"sources":["../../../src/internal-plugins/query-runner/page-query-runner.js"],"names":["_","require","queue","store","emitter","queuedDirtyActions","active","exports","runQueries","uniq","a","payload","id","dirtyIds","findDirtyIds","runQueriesForIds","cleanIds","findIdsWithoutDataDependencies","on","action","push","node","runQueuedActions","seenIdsWithoutDataDependencies","state","getState","allTrackedIds","flatten","concat","values","componentDataDependencies","nodes","connections","notTrackedIds","difference","pages","map","p","path","layouts","l","ids","pagesAndLayouts","didNotQueueItems","forEach","plObj","find","pl","_id","jsonName","length","Promise","resolve","actions","reduce","internal","type","compact"],"mappings":"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","file":"page-query-runner.js","sourcesContent":["/**\n * Jobs of this module\n * - Ensure on bootstrap that all invalid page queries are run and report\n *   when this is done\n * - Watch for when a page's query is invalidated and re-run it.\n */\n\nconst _ = require(`lodash`)\n\nconst queue = require(`./query-queue`)\nconst { store, emitter } = require(`../../redux`)\n\nlet queuedDirtyActions = []\nlet active = false\n\n// Do initial run of graphql queries during bootstrap.\n// Afterwards we listen \"API_RUNNING_QUEUE_EMPTY\" and check\n// for dirty nodes before running queries.\nexports.runQueries = async () => {\n  // Run queued dirty nodes now that we're active.\n  queuedDirtyActions = _.uniq(queuedDirtyActions, a => a.payload.id)\n  const dirtyIds = findDirtyIds(queuedDirtyActions)\n  await runQueriesForIds(dirtyIds)\n\n  queuedDirtyActions = []\n\n  // Find ids without data dependencies (i.e. no queries have been run for\n  // them before) and run them.\n  const cleanIds = findIdsWithoutDataDependencies()\n\n  // Run these pages\n  await runQueriesForIds(cleanIds)\n\n  active = true\n  return\n}\n\nemitter.on(`CREATE_NODE`, action => {\n  queuedDirtyActions.push(action)\n})\n\nemitter.on(`DELETE_NODE`, action => {\n  queuedDirtyActions.push({ payload: action.node })\n})\n\nconst runQueuedActions = async () => {\n  if (active) {\n    queuedDirtyActions = _.uniq(queuedDirtyActions, a => a.payload.id)\n    await runQueriesForIds(findDirtyIds(queuedDirtyActions))\n    queuedDirtyActions = []\n\n    // Find ids without data dependencies (e.g. new pages) and run\n    // their queries.\n    const cleanIds = findIdsWithoutDataDependencies()\n    runQueriesForIds(cleanIds)\n  }\n}\n\n// Wait until all plugins have finished running (e.g. various\n// transformer plugins) before running queries so we don't\n// query things in a 1/2 finished state.\nemitter.on(`API_RUNNING_QUEUE_EMPTY`, runQueuedActions)\n\nlet seenIdsWithoutDataDependencies = []\nconst findIdsWithoutDataDependencies = () => {\n  const state = store.getState()\n  const allTrackedIds = _.uniq(\n    _.flatten(\n      _.concat(\n        _.values(state.componentDataDependencies.nodes),\n        _.values(state.componentDataDependencies.connections)\n      )\n    )\n  )\n\n  // Get list of paths not already tracked and run the queries for these\n  // paths.\n  const notTrackedIds = _.difference(\n    [\n      ...state.pages.map(p => p.path),\n      ...state.layouts.map(l => `LAYOUT___${l.id}`),\n    ],\n    [...allTrackedIds, ...seenIdsWithoutDataDependencies]\n  )\n\n  // Add new IDs to our seen array so we don't keep trying to run queries for them.\n  // Pages/Layouts without queries can't be tracked.\n  seenIdsWithoutDataDependencies = _.uniq([\n    ...notTrackedIds,\n    ...seenIdsWithoutDataDependencies,\n  ])\n\n  return notTrackedIds\n}\n\nconst runQueriesForIds = ids => {\n  const state = store.getState()\n  const pagesAndLayouts = [...state.pages, ...state.layouts]\n  let didNotQueueItems = true\n  ids.forEach(id => {\n    const plObj = pagesAndLayouts.find(\n      pl => pl.path === id || `LAYOUT___${pl.id}` === id\n    )\n    if (plObj) {\n      didNotQueueItems = false\n      queue.push({ ...plObj, _id: plObj.id, id: plObj.jsonName })\n    }\n  })\n\n  if (didNotQueueItems || !ids || ids.length === 0) {\n    return Promise.resolve()\n  }\n\n  return new Promise(resolve => {\n    queue.on(`drain`, () => {\n      resolve()\n    })\n  })\n}\n\nconst findDirtyIds = actions => {\n  const state = store.getState()\n  return _.uniq(\n    actions.reduce((dirtyIds, action) => {\n      const node = action.payload\n\n      if (!node || !node.id || !node.internal.type) return dirtyIds\n\n      // Find pagesAndLayouts that depend on this node so are now dirty.\n      dirtyIds = dirtyIds.concat(state.componentDataDependencies.nodes[node.id])\n\n      // Find connections that depend on this node so are now invalid.\n      dirtyIds = dirtyIds.concat(\n        state.componentDataDependencies.connections[node.internal.type]\n      )\n\n      return _.compact(dirtyIds)\n    }, [])\n  )\n}\n"]}