var _objectWithoutProperties = require("@babel/runtime/helpers/objectWithoutProperties");

var _asyncToGenerator = require("@babel/runtime/helpers/asyncToGenerator");

const os = require(`os`);

const autoprefixer = require(`autoprefixer`);

const ExtractTextPlugin = require(`extract-text-webpack-plugin`);

const flexbugs = require(`postcss-flexbugs-fixes`);

const UglifyPlugin = require(`uglifyjs-webpack-plugin`);

const builtinPlugins = require(`./webpack-plugins`);

const _require = require(`./babel-config`),
      createBabelConfig = _require.createBabelConfig;

/**
 * A factory method that produces an atoms namespace
 */
module.exports =
/*#__PURE__*/
function () {
  var _ref = _asyncToGenerator(function* ({
    stage,
    program
  }) {
    const assetRelativeRoot = `static/`;
    const vendorRegex = /(node_modules|bower_components)/;
    const supportedBrowsers = program.browserlist;
    const PRODUCTION = !stage.includes(`develop`);
    const babelConfig = yield createBabelConfig(program, stage);

    const makeExternalOnly = original => (options = {}) => {
      let rule = original(options);
      rule.include = vendorRegex;
      return rule;
    };

    const makeInternalOnly = original => (options = {}) => {
      let rule = original(options);
      rule.exclude = vendorRegex;
      return rule;
    };

    let ident = 0;
    const loaders = {
      json: (options = {}) => {
        return {
          options,
          loader: require.resolve(`json-loader`)
        };
      },
      yaml: (options = {}) => {
        return {
          options,
          loader: require.resolve(`yaml-loader`)
        };
      },
      null: (options = {}) => {
        return {
          options,
          loader: require.resolve(`null-loader`)
        };
      },
      raw: (options = {}) => {
        return {
          options,
          loader: require.resolve(`raw-loader`)
        };
      },
      style: (options = {}) => {
        return {
          options,
          loader: require.resolve(`style-loader`)
        };
      },
      css: (options = {}) => {
        return {
          loader: require.resolve(`css-loader`),
          options: Object.assign({
            minimize: PRODUCTION,
            sourceMap: !PRODUCTION,
            camelCase: `dashesOnly`,
            // https://github.com/webpack-contrib/css-loader/issues/406
            localIdentName: `[name]--[local]--[hash:base64:5]`
          }, options)
        };
      },
      postcss: (options = {}) => {
        let plugins = options.plugins,
            _options$browsers = options.browsers,
            browsers = _options$browsers === void 0 ? supportedBrowsers : _options$browsers,
            postcssOpts = _objectWithoutProperties(options, ["plugins", "browsers"]);

        return {
          loader: require.resolve(`postcss-loader`),
          options: Object.assign({
            ident: `postcss-${++ident}`,
            sourceMap: !PRODUCTION,
            plugins: function (_plugins) {
              function plugins(_x2) {
                return _plugins.apply(this, arguments);
              }

              plugins.toString = function () {
                return _plugins.toString();
              };

              return plugins;
            }(loader => {
              plugins = (typeof plugins === `function` ? plugins(loader) : plugins) || [];
              return [flexbugs, autoprefixer({
                browsers,
                flexbox: `no-2009`
              }), ...plugins];
            })
          }, postcssOpts)
        };
      },
      file: (options = {}) => {
        return {
          loader: require.resolve(`url-loader`),
          options: Object.assign({
            name: `${assetRelativeRoot}[name]-[hash].[ext]`
          }, options)
        };
      },
      url: (options = {}) => {
        return {
          loader: require.resolve(`url-loader`),
          options: Object.assign({
            limit: 10000,
            name: `${assetRelativeRoot}[name]-[hash].[ext]`
          }, options)
        };
      },
      js: (options = babelConfig) => {
        return {
          options,
          loader: require.resolve(`babel-loader`)
        };
      },
      imports: (options = {}) => {
        return {
          options,
          loader: require.resolve(`imports-loader`)
        };
      },
      exports: (options = {}) => {
        return {
          options,
          loader: require.resolve(`exports-loader`)
        };
      }
      /**
       * Rules
       */

    };
    const rules = {};
    /**
     * Javascript loader via babel, excludes node_modules
     */

    {
      let js = options => {
        return {
          test: /\.jsx?$/,
          exclude: vendorRegex,
          use: [loaders.js(options)]
        };
      };

      rules.js = js;
    }

    rules.yaml = () => {
      return {
        test: /\.ya?ml/,
        use: [loaders.json(), loaders.yaml()]
      };
    };
    /**
     * Font loader
     */


    rules.fonts = () => {
      return {
        use: [loaders.url()],
        test: /\.(eot|otf|ttf|woff(2)?)(\?.*)?$/
      };
    };
    /**
     * Loads image assets, inlines images via a data URI if they are below
     * the size threshold
     */


    rules.images = () => {
      return {
        use: [loaders.url()],
        test: /\.(ico|svg|jpg|jpeg|png|gif|webp)(\?.*)?$/
      };
    };
    /**
     * Loads audio or video assets
     */


    rules.audioVideo = () => {
      return {
        use: [loaders.file()],
        test: /\.(mp4|webm|wav|mp3|m4a|aac|oga|flac)$/
      };
    };
    /**
     * CSS style loader.
     */


    {
      const css = (_ref2 = {}) => {
        let browsers = _ref2.browsers,
            options = _objectWithoutProperties(_ref2, ["browsers"]);

        return {
          test: /\.css$/,
          use: ExtractTextPlugin.extract({
            fallback: loaders.style(),
            use: [loaders.css(Object.assign({}, options, {
              importLoaders: 1
            })), loaders.postcss({
              browsers
            })]
          })
        };
      };
      /**
       * CSS style loader, _excludes_ node_modules.
       */


      css.internal = makeInternalOnly(css);
      css.external = makeExternalOnly(css);

      const cssModules = options => {
        const rule = css(Object.assign({}, options, {
          modules: true
        }));
        delete rule.exclude;
        rule.test = /\.module\.css$/;
        return rule;
      };

      rules.css = css;
      rules.cssModules = cssModules;
    }
    /**
     * PostCSS loader.
     */

    {
      const postcss = options => {
        return {
          test: /\.css$/,
          use: ExtractTextPlugin.extract({
            fallback: loaders.style(),
            use: [loaders.css({
              importLoaders: 1
            }), loaders.postcss(options)]
          })
        };
      };
      /**
       * PostCSS loader, _excludes_ node_modules.
       */


      postcss.internal = makeInternalOnly(postcss);
      postcss.external = makeExternalOnly(postcss);
      rules.postcss = postcss;
    }
    /**
     * Plugins
     */

    const plugins = Object.assign({}, builtinPlugins);
    /**
     * Minify javascript code without regard for IE8. Attempts
     * to parallelize the work to save time. Generally only add in Production
     */

    plugins.uglify = (_ref3 = {}) => {
      let uglifyOptions = _ref3.uglifyOptions,
          options = _objectWithoutProperties(_ref3, ["uglifyOptions"]);

      return new UglifyPlugin(Object.assign({
        cache: true,
        parallel: os.cpus().length - 1,
        exclude: /\.min\.js/,
        sourceMap: true,
        uglifyOptions: Object.assign({
          compress: {
            drop_console: true
          },
          ecma: 8,
          ie8: false
        }, uglifyOptions)
      }, options));
    };
    /**
     * Extracts css requires into a single file;
     * includes some reasonable defaults
     */


    plugins.extractText = options => new ExtractTextPlugin(Object.assign({
      filename: `[name]-[contenthash].css`,
      allChunks: true,
      disable: !PRODUCTION,
      // Useful when using css modules
      ignoreOrder: true
    }, options));

    plugins.extractText.extract = (...args) => ExtractTextPlugin.extract(...args);

    plugins.moment = () => plugins.ignore(/^\.\/locale$/, /moment$/);

    return {
      loaders,
      rules: rules,
      plugins: plugins
    };
  });

  return function (_x) {
    return _ref.apply(this, arguments);
  };
}();
//# sourceMappingURL=webpack-utils.js.map