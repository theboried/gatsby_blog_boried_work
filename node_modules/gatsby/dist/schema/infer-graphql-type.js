"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.findLinkedNode = findLinkedNode;
exports.inferObjectStructureFromNodes = inferObjectStructureFromNodes;

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

const _require = require(`graphql`),
      GraphQLObjectType = _require.GraphQLObjectType,
      GraphQLBoolean = _require.GraphQLBoolean,
      GraphQLString = _require.GraphQLString,
      GraphQLFloat = _require.GraphQLFloat,
      GraphQLInt = _require.GraphQLInt,
      GraphQLList = _require.GraphQLList,
      GraphQLUnionType = _require.GraphQLUnionType;

const _ = require(`lodash`);

const invariant = require(`invariant`);

const _require2 = require(`common-tags`),
      oneLine = _require2.oneLine;

const _require3 = require(`../redux`),
      store = _require3.store,
      getNode = _require3.getNode,
      getNodes = _require3.getNodes;

const _require4 = require(`../redux/actions/add-page-dependency`),
      createPageDependency = _require4.createPageDependency;

const createTypeName = require(`./create-type-name`);

const createKey = require(`./create-key`);

const _require5 = require(`./data-tree-utils`),
      extractFieldExamples = _require5.extractFieldExamples,
      isEmptyObjectOrArray = _require5.isEmptyObjectOrArray;

const DateType = require(`./types/type-date`);

const FileType = require(`./types/type-file`);

function inferGraphQLType(_ref) {
  let exampleValue = _ref.exampleValue,
      selector = _ref.selector,
      nodes = _ref.nodes,
      types = _ref.types,
      otherArgs = (0, _objectWithoutProperties2.default)(_ref, ["exampleValue", "selector", "nodes", "types"]);
  if (exampleValue == null || isEmptyObjectOrArray(exampleValue)) return null;
  let fieldName = selector.split(`.`).pop(); // Check this before checking for array as FileType has
  // builtin support for inferring array of files and inferred
  // array type will have faster resolver than resolving array
  // of files separately.

  if (FileType.shouldInfer(nodes, selector, exampleValue)) {
    return _.isArray(exampleValue) ? FileType.getListType() : FileType.getType();
  }

  if (Array.isArray(exampleValue)) {
    exampleValue = exampleValue[0];
    if (exampleValue == null) return null;
    let inferredType = inferGraphQLType(Object.assign({}, otherArgs, {
      exampleValue,
      selector,
      nodes,
      types
    }));
    invariant(inferredType, `Could not infer graphQL type for value: ${exampleValue}`);
    const type = inferredType.type,
          _inferredType$args = inferredType.args,
          args = _inferredType$args === void 0 ? null : _inferredType$args,
          _inferredType$resolve = inferredType.resolve,
          resolve = _inferredType$resolve === void 0 ? null : _inferredType$resolve;
    const listType = {
      type: new GraphQLList(type),
      args
    };

    if (resolve) {
      // If inferredType has resolve function wrap it with Array.map
      listType.resolve = (object, args, context, resolveInfo) => {
        const fieldValue = object[fieldName];

        if (!fieldValue) {
          return null;
        } // Field resolver expects first parameter to be plain object
        // containing key with name of field we want to resolve.


        return fieldValue.map(value => resolve({
          [fieldName]: value
        }, args, context, resolveInfo));
      };
    }

    return listType;
  }

  if (DateType.shouldInfer(exampleValue)) {
    return DateType.getType();
  }

  switch (typeof exampleValue) {
    case `boolean`:
      return {
        type: GraphQLBoolean
      };

    case `string`:
      return {
        type: GraphQLString
      };

    case `object`:
      return {
        type: new GraphQLObjectType({
          name: createTypeName(fieldName),
          fields: inferObjectStructureFromNodes(Object.assign({}, otherArgs, {
            exampleValue,
            selector,
            nodes,
            types
          }))
        })
      };

    case `number`:
      return _.isInteger(exampleValue) ? {
        type: GraphQLInt
      } : {
        type: GraphQLFloat
      };

    default:
      return null;
  }
}

function inferFromMapping(value, mapping, fieldSelector, types) {
  const matchedTypes = types.filter(type => type.name === mapping[fieldSelector]);

  if (_.isEmpty(matchedTypes)) {
    console.log(`Couldn't find a matching node type for "${fieldSelector}"`);
    return null;
  }

  const findNode = (fieldValue, path) => {
    const linkedType = mapping[fieldSelector];

    const linkedNode = _.find(getNodes(), n => n.internal.type === linkedType && n.id === fieldValue);

    if (linkedNode) {
      createPageDependency({
        path,
        nodeId: linkedNode.id
      });
      return linkedNode;
    }

    return null;
  };

  if (_.isArray(value)) {
    return {
      type: new GraphQLList(matchedTypes[0].nodeObjectType),
      resolve: (node, a, b, {
        fieldName
      }) => {
        const fieldValue = node[fieldName];

        if (fieldValue) {
          return fieldValue.map(value => findNode(value, b.path));
        } else {
          return null;
        }
      }
    };
  }

  return {
    type: matchedTypes[0].nodeObjectType,
    resolve: (node, a, b, {
      fieldName
    }) => {
      const fieldValue = node[fieldName];

      if (fieldValue) {
        return findNode(fieldValue, b.path);
      } else {
        return null;
      }
    }
  };
}

function findLinkedNode(value, linkedField, path) {
  let linkedNode; // If the field doesn't link to the id, use that for searching.

  if (linkedField) {
    linkedNode = getNodes().find(n => n[linkedField] === value); // Else the field is linking to the node's id, the default.
  } else {
    linkedNode = getNode(value);
  }

  if (linkedNode) {
    if (path) createPageDependency({
      path,
      nodeId: linkedNode.id
    });
    return linkedNode;
  }

  return null;
}

function inferFromFieldName(value, selector, types) {
  let isArray = false;

  if (_.isArray(value)) {
    isArray = true; // Reduce values to nodes with unique types.

    value = _.uniqBy(value, v => getNode(v).internal.type);
  }

  const key = selector.split(`.`).pop();

  const _key$split = key.split(`___`),
        linkedField = _key$split[2];

  const validateLinkedNode = linkedNode => {
    invariant(linkedNode, oneLine`
        Encountered an error trying to infer a GraphQL type for: "${selector}".
        There is no corresponding node with the ${linkedField || `id`}
        field matching: "${value}"
      `);
  };

  const validateField = (linkedNode, field) => {
    invariant(field, oneLine`
        Encountered an error trying to infer a GraphQL type for: "${selector}".
        There is no corresponding GraphQL type "${linkedNode.internal.type}" available
        to link to this node.
      `);
  };

  const findNodeType = node => types.find(type => type.name === node.internal.type);

  if (isArray) {
    const linkedNodes = value.map(v => findLinkedNode(v));
    linkedNodes.forEach(node => validateLinkedNode(node));
    const fields = linkedNodes.map(node => findNodeType(node));
    fields.forEach((field, i) => validateField(linkedNodes[i], field));
    let type; // If there's more than one type, we'll create a union type.

    if (fields.length > 1) {
      type = new GraphQLUnionType({
        name: `Union_${key}_${fields.map(f => f.name).sort().join(`__`)}`,
        description: `Union interface for the field "${key}" for types [${fields.map(f => f.name).sort().join(`, `)}]`,
        types: fields.map(f => f.nodeObjectType),
        resolveType: data => fields.find(f => f.name == data.internal.type).nodeObjectType
      });
    } else {
      type = fields[0].nodeObjectType;
    }

    return {
      type: new GraphQLList(type),
      resolve: (node, a, b = {}) => {
        let fieldValue = node[key];

        if (fieldValue) {
          return fieldValue.map(value => findLinkedNode(value, linkedField, b.path));
        } else {
          return null;
        }
      }
    };
  }

  const linkedNode = findLinkedNode(value, linkedField);
  validateLinkedNode(linkedNode);
  const field = findNodeType(linkedNode);
  validateField(linkedNode, field);
  return {
    type: field.nodeObjectType,
    resolve: (node, a, b = {}) => {
      let fieldValue = node[key];

      if (fieldValue) {
        const result = findLinkedNode(fieldValue, linkedField, b.path);
        return result;
      } else {
        return null;
      }
    }
  };
}

const EXCLUDE_KEYS = {
  id: 1,
  parent: 1,
  children: 1 // Call this for the top level node + recursively for each sub-object.
  // E.g. This gets called for Markdown and then for its frontmatter subobject.

};

function inferObjectStructureFromNodes({
  nodes,
  types,
  selector,
  exampleValue = extractFieldExamples(nodes)
}) {
  const config = store.getState().config;
  const isRoot = !selector;
  const mapping = config && config.mapping; // Ensure nodes have internal key with object.

  nodes = nodes.map(n => n.internal ? n : Object.assign({}, n, {
    internal: {}
  }));
  const inferredFields = {};

  _.each(exampleValue, (value, key) => {
    // Remove fields common to the top-level of all nodes.  We add these
    // elsewhere so don't need to infer their type.
    if (isRoot && EXCLUDE_KEYS[key]) return; // Several checks to see if a field is pointing to custom type
    // before we try automatic inference.

    const nextSelector = selector ? `${selector}.${key}` : key;
    const fieldSelector = `${nodes[0].internal.type}.${nextSelector}`;
    let fieldName = key;
    let inferredField; // First check for manual field => type mappings in the site's
    // gatsby-config.js

    if (mapping && _.includes(Object.keys(mapping), fieldSelector)) {
      inferredField = inferFromMapping(value, mapping, fieldSelector, types); // Second if the field has a suffix of ___node. We use then the value
      // (a node id) to find the node and use that node's type as the field
    } else if (_.includes(key, `___NODE`)) {
      ;

      var _key$split2 = key.split(`___`);

      fieldName = _key$split2[0];
      inferredField = inferFromFieldName(value, nextSelector, types);
    } // Finally our automatic inference of field value type.


    if (!inferredField) {
      inferredField = inferGraphQLType({
        nodes,
        types,
        exampleValue: value,
        selector: nextSelector
      });
    }

    if (!inferredField) return; // Replace unsupported values

    inferredFields[createKey(fieldName)] = inferredField;
  });

  return inferredFields;
}
//# sourceMappingURL=infer-graphql-type.js.map