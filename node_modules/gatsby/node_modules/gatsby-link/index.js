"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.withPrefix = withPrefix;
exports.navigateTo = exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _keys = _interopRequireDefault(require("@babel/runtime/core-js/object/keys"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _inheritsLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/inheritsLoose"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _react = _interopRequireDefault(require("react"));

var _reactRouterDom = require("react-router-dom");

var _propTypes = _interopRequireDefault(require("prop-types"));

var _history = require("history");

/*global __PREFIX_PATHS__, __PATH_PREFIX__ */
var pathPrefix = "/";

if (typeof __PREFIX_PATHS__ !== "undefined" && __PREFIX_PATHS__) {
  pathPrefix = __PATH_PREFIX__;
}

function withPrefix(path) {
  return normalizePath(pathPrefix + path);
}

function normalizePath(path) {
  return path.replace(/^\/\//g, "/");
}

function createLocation(path, history) {
  var location = (0, _history.createLocation)(path, null, null, history.location);
  location.pathname = withPrefix(location.pathname);
  return location;
}

var NavLinkPropTypes = {
  activeClassName: _propTypes.default.string,
  activeStyle: _propTypes.default.object,
  exact: _propTypes.default.bool,
  strict: _propTypes.default.bool,
  isActive: _propTypes.default.func,
  location: _propTypes.default.object // Set up IntersectionObserver

};

var handleIntersection = function handleIntersection(el, cb) {
  var io = new window.IntersectionObserver(function (entries) {
    entries.forEach(function (entry) {
      if (el === entry.target) {
        // Check if element is within viewport, remove listener, destroy observer, and run link callback.
        // MSEdge doesn't currently support isIntersecting, so also test for  an intersectionRatio > 0
        if (entry.isIntersecting || entry.intersectionRatio > 0) {
          io.unobserve(el);
          io.disconnect();
          cb();
        }
      }
    });
  }); // Add element to the observer

  io.observe(el);
};

var GatsbyLink =
/*#__PURE__*/
function (_React$Component) {
  (0, _inheritsLoose2.default)(GatsbyLink, _React$Component);

  function GatsbyLink(props, context) {
    var _this;

    _this = _React$Component.call(this) || this; // Default to no support for IntersectionObserver

    var IOSupported = false;

    if (typeof window !== "undefined" && window.IntersectionObserver) {
      IOSupported = true;
    }

    var history = context.router.history;
    var to = createLocation(props.to, history);
    _this.state = {
      path: (0, _history.createPath)(to),
      to: to,
      IOSupported: IOSupported
    };
    _this.handleRef = _this.handleRef.bind((0, _assertThisInitialized2.default)(_this));
    return _this;
  }

  var _proto = GatsbyLink.prototype;

  _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    if (this.props.to !== nextProps.to) {
      var to = createLocation(nextProps.to, history);
      this.setState({
        path: (0, _history.createPath)(to),
        to: to
      }); // Preserve non IO functionality if no support

      if (!this.state.IOSupported) {
        ___loader.enqueue(this.state.path);
      }
    }
  };

  _proto.componentDidMount = function componentDidMount() {
    // Preserve non IO functionality if no support
    if (!this.state.IOSupported) {
      ___loader.enqueue(this.state.path);
    }
  };

  _proto.handleRef = function handleRef(ref) {
    var _this2 = this;

    this.props.innerRef && this.props.innerRef(ref);

    if (this.state.IOSupported && ref) {
      // If IO supported and element reference found, setup Observer functionality
      handleIntersection(ref, function () {
        ___loader.enqueue(_this2.state.path);
      });
    }
  };

  _proto.render = function render() {
    var _this3 = this;

    var _props = this.props,
        _onClick = _props.onClick,
        rest = (0, _objectWithoutProperties2.default)(_props, ["onClick"]);
    var El;

    if ((0, _keys.default)(NavLinkPropTypes).some(function (propName) {
      return _this3.props[propName];
    })) {
      El = _reactRouterDom.NavLink;
    } else {
      El = _reactRouterDom.Link;
    }

    return _react.default.createElement(El, (0, _extends2.default)({
      onClick: function onClick(e) {
        // eslint-disable-line
        _onClick && _onClick(e);

        if (e.button === 0 && // ignore right clicks
        !_this3.props.target && // let browser handle "target=_blank"
        !e.defaultPrevented && // onClick prevented default
        !e.metaKey && // ignore clicks with modifier keys...
        !e.altKey && !e.ctrlKey && !e.shiftKey) {
          // Is this link pointing to a hash on the same page? If so,
          // just scroll there.
          var pathname = _this3.state.path;

          if (pathname.split("#").length > 1) {
            pathname = pathname.split("#").slice(0, -1).join("");
          }

          if (pathname === window.location.pathname) {
            var hashFragment = _this3.state.path.split("#").slice(1).join("#");

            var element = document.getElementById(hashFragment);

            if (element !== null) {
              element.scrollIntoView();
              return true;
            } else {
              // This is just a normal link to the current page so let's emulate default
              // browser behavior by scrolling now to the top of the page.
              window.scrollTo(0, 0);
              return true;
            }
          } // In production, make sure the necessary scripts are
          // loaded before continuing.


          if (process.env.NODE_ENV === "production") {
            e.preventDefault();

            window.___navigateTo(_this3.state.to);
          }
        }

        return true;
      }
    }, rest, {
      to: this.state.to,
      innerRef: this.handleRef
    }));
  };

  return GatsbyLink;
}(_react.default.Component);

GatsbyLink.propTypes = (0, _extends2.default)({}, NavLinkPropTypes, {
  innerRef: _propTypes.default.func,
  onClick: _propTypes.default.func,
  to: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.object]).isRequired
});
GatsbyLink.contextTypes = {
  router: _propTypes.default.object
};
var _default = GatsbyLink;
exports.default = _default;

var navigateTo = function navigateTo(to) {
  window.___navigateTo(to);
};

exports.navigateTo = navigateTo;